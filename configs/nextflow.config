/*
profiles {
    stub {
        stubRun = true
        process {
            {
                executor = 'local'
                cpus = 1
                memory = '1 GB'
                time = '1h'
            }
        }
        params{
            sample_id = "test"
            joint_vcf = "test/test.chr21.vcf.gz"
        }
    }
}
*/

def getGcpProject() {
    def proc = "gcloud config get-value project".execute()
    proc.waitFor()
    return proc.in.text.trim()
}

def getMetadataNetwork() {
    try {
        // We gebruiken een array voor het commando, dit is veiliger in Groovy
        def cmd = ["curl", "-s", "-f", "-H", "Metadata-Flavor: Google", "http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/network"]
        def proc = cmd.execute()
        proc.waitFor()
        if (proc.exitValue() == 0) {
            return proc.in.text.trim()
        }
    } catch (Exception e) {
        // Log de fout naar de console voor debugging
        System.err.println "WARNING: Could not fetch network metadata: ${e.message}"
    }
    return null
}


profiles {
    gcp{
        docker.enabled = true
        docker.autoMounts = true
        docker.registry      = 'quay.io'
        containerOptions = '-e TMPDIR=/tmp'
        process.executor = 'google-batch'
        process.queueSize = 1000
        process.pollInterval = '60sec'
        
        params.artifact_registry_path = 'europe-west4-docker.pkg.dev/pmc-gcp-box-d-pip-resources/pipeline-containers'

        
        gcp_region = 'europe-west4'
        gcp_network = getMetadataNetwork().replaceFirst(/networks/, "global/networks")
        gcp_subnetwork = gcp_network.replace('/global/networks/', "/regions/${gcp_region}/subnetworks/").replace('shared-vpc-', 'subnet-')
        gcp_project = getGcpProject()

        google.region  = "${gcp_region}"
        google.project = "${gcp_project}"
        google.location = "${gcp_region}"
        
        //google.region  = 'europe-west4'
        //google.project = "pmc-gcp-box-d-pip-development"
        //google.location = 'europe-west4'

        google.batch.spot = true
        google.batch.autoRetryExitCodes = [104, 9, 50001, 50002, 50003, 50004, 50005, 50006]
        google.batch.maxSpotAttempts = 10


        google.batch.usePrivateAddress = true
        google.batch.network = "${gcp_network}"
        google.batch.subnetwork = "${gcp_subnetwork}"
        google.batch.serviceAccountEmail = "sa-nextflow-runner@${gcp_project}.iam.gserviceaccount.com"

        //google.batch.network =  'projects/pmc-vpc-res-private-20gx/global/networks/shared-vpc-res-priv-dev'
        //google.batch.subnetwork = 'projects/pmc-vpc-res-private-20gx/regions/europe-west4/subnetworks/subnet-res-priv-dev'
        //google.batch.serviceAccountEmail = "sa-nextflow-runner@${gcp_project}.iam.gserviceaccount.com"
        //google.batch.serviceAccountEmail = "sa-nextflow-runner@pmc-gcp-box-d-pip-development.iam.gserviceaccount.com"
    }
    
    hpc {
        process.executor = 'slurm'
        process.queue = 'cpu'

        singularity.enabled = true
        singularity.autoMounts = true
        singularity.runOptions = '-B /hpc -B $TMPDIR:$TMPDIR'
        singularity.cacheDir = '/hpc/local/Rocky8/pmc_vanboxtel/singularity_cache'
    }
}

process {
    queue = { task.accelerator ? 'gpu' : (task.memory > 100.GB ? 'bigmem' : 'cpu') }
    errorStrategy = { task.exitStatus in [143,137,104,134,139] ? 'retry' : 'terminate' }
    maxRetries = 2
    maxErrors = '-1'
    cache = 'lenient'
}


executor {
  queueSize = 196
  submitRateLimit = '5 sec'
}

report {
    enabled = true
    overwrite = true
    file = "nextflow-report.html"
}

timeline {
    enabled = true
    overwrite = true
    file = "timeline.html"
}

dag {
    enabled = true
    overwrite = true
    file = "flowchart.html"
}

manifest {
    name = "cloudCellphy"
    version = "v0.0.3"
    author = ["John Zinno"]
    homePage = "https://github.com/jzinno/cloudCellphy"
    defaultBranch = "main"
    nextflowVersion = ">=22.10.4"
}

